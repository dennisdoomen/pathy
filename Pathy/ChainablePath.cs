// <autogenerated />

using System;
using System.IO;

#pragma warning disable

namespace Pathy;

/// <summary>
/// Represents an absolute or relative path to a directory or file that simplifies operations like combining paths using
/// the <c>/</c> operator
/// </summary>
#if PATHY_PUBLIC
public readonly record struct ChainablePath
#else
internal readonly record struct ChainablePath
#endif
{
    private readonly string path = string.Empty;

    private ChainablePath(string path)
    {
        this.path = path;
    }

    /// <summary>
    /// Represents an empty <see cref="ChainablePath"/> instance.
    /// </summary>
    public static ChainablePath Empty { get; } = new(string.Empty);

    /// <summary>
    /// Gets a default, empty <see cref="ChainablePath"/> instance.
    /// </summary>
    public static ChainablePath New => new(string.Empty);

    /// <summary>
    /// Creates a new instance of <see cref="ChainablePath"/> representing the specified path.
    /// </summary>
    /// <param name="path">
    /// The string representation of the path. This can be relative or absolute.
    /// </param>
    /// <returns>
    /// A <see cref="ChainablePath"/> object representing the normalized path.
    /// </returns>
    /// <exception cref="ArgumentException">
    /// Thrown if the <paramref name="path"/> is null, empty, or invalid.
    /// </exception>
    public static ChainablePath From(string path)
    {
        if (path is null or { Length: 0 })
        {
            throw new ArgumentException("Path cannot be null or empty", nameof(path));
        }

        try
        {
            path = NormalizeSlashes(path);

            if (path[path.Length - 1] == Path.VolumeSeparatorChar)
            {
                path += Path.DirectorySeparatorChar;
            }

            if (Path.IsPathRooted(path))
            {
                return new ChainablePath(Path.GetFullPath(path));
            }

            return new ChainablePath(path);
        }
        catch (NotSupportedException)
        {
            throw new ArgumentException($"Path {path} is not valid", nameof(path));
        }
    }

    private static string NormalizeSlashes(string path)
    {
        return path.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
    }

    /// <summary>
    /// Combines a <see cref="ChainablePath"/> instance with a string representing a sub-path while
    /// handling the path separators suitable for the specific operating system.
    /// </summary>
    /// <example>
    /// <code>
    /// var combinedPath = ChainablePath.From("C:/BasePath") / "SubPath" / "File.txt";
    /// </code>
    /// </example>
    /// <remarks>
    /// You don't need to add any slashes before the sub-path. The operator will handle it for you.
    /// </remarks>
    /// <param name="leftPath">
    /// The base <see cref="ChainablePath"/> to which the <paramref name="subPath"/> will be appended.
    /// </param>
    /// <param name="subPath">
    /// The string representation of the relative or additional path to combine with <paramref name="leftPath"/>.
    /// </param>
    /// <returns>
    /// A new <see cref="ChainablePath"/> instance representing the combined path.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown if either <paramref name="leftPath"/> or <paramref name="subPath"/> is null.
    /// </exception>
    public static ChainablePath operator /(ChainablePath leftPath, string subPath)
    {
        return From(Path.Combine(leftPath.path, subPath));
    }

    /// <summary>
    /// Combines a <see cref="ChainablePath"/> instance with a string representing a sub-path while
    /// handling the path separators suitable for the specific operating system.
    /// </summary>
    /// <example>
    /// <code>
    /// var combinedPath = ChainablePath.From("C:/BasePath") / "SubPath" / "File.txt";
    /// </code>
    /// </example>
    /// <remarks>
    /// You don't need to add any slashes before the sub-path. The operator will handle it for you.
    /// </remarks>
    /// <param name="leftPath">
    /// The base <see cref="ChainablePath"/> to which the <paramref name="subPath"/> will be appended.
    /// </param>
    /// <param name="subPath">
    /// The string representation of the relative or additional path to combine with <paramref name="leftPath"/>.
    /// </param>
    /// <returns>
    /// A new <see cref="ChainablePath"/> instance representing the combined path.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown if either <paramref name="leftPath"/> or <paramref name="subPath"/> is null.
    /// </exception>
    public static ChainablePath operator /(ChainablePath? leftPath, string subPath)
    {
        return From(Path.Combine(leftPath.GetValueOrDefault(New), subPath));
    }

    /// <summary>
    /// Adds a raw string to the end of a <see cref="ChainablePath"/> instance.
    /// </summary>
    /// <param name="leftPath">
    /// The base <see cref="ChainablePath"/> object representing an initial path.
    /// </param>
    /// <param name="additionalPath">
    /// The additional string representing a relative path or file extension (with dot) to append to the <paramref name="leftPath"/>.
    /// </param>
    /// <returns>
    /// A new <see cref="ChainablePath"/> instance representing the combined path of <paramref name="leftPath"/> and <paramref name="additionalPath"/>.
    /// </returns>
    public static ChainablePath operator +(ChainablePath leftPath, string additionalPath)
    {
        return From(leftPath.ToString() + additionalPath);
    }

    /// <summary>
    /// Gets the name of the file or directory represented by the current path, without the parent directory.
    /// </summary>
    public string Name => Path.GetFileName(path);

    /// <summary>
    /// If the current path represents a file, gets the directory of that file.
    /// Or, if the current path represents a directory, gets the parent directory.
    /// Returns <see cref="Empty"/> if the path represents the root of a file system.
    /// </summary>
    public ChainablePath Directory
    {
        get
        {
            string directory = DirectoryName;
            if (directory.Length > 0)
            {
                return From(directory);
            }

            return Empty;
        }
    }

    /// <summary>
    /// If the current path represents a file, gets the directory of that file.
    /// Or, if the current path represents a directory, gets the parent directory.
    /// Returns <see cref="Empty"/> if the path represents the root of a file system.
    /// </summary>
    public ChainablePath Parent => From(DirectoryName);

    /// <summary>
    /// If the current path represents a file, gets the directory of that file.
    /// Or, if the current path represents a directory, gets the parent directory.
    /// Returns an empty string if the path represents the root of a file system.
    /// </summary>
    public string DirectoryName
    {
        get
        {
            return Path.GetDirectoryName(path.TrimEnd(Path.DirectorySeparatorChar)) ?? "";
        }
    }

    /// <summary>
    /// Indicates whether the current path is rooted, meaning it begins with a root component such as
    /// a drive letter (e.g., "C:\") or directory separator (e.g., "/").
    /// Returns <c>true</c> if the path is rooted; otherwise, <c>false</c>.
    /// </summary>
    public bool IsRooted => Path.IsPathRooted(path);

    /// <summary>
    /// Returns <c>true</c> if the path represents an existing file or directory; otherwise, returns <c>false</c>.
    /// </summary>
    public bool Exists => FileExists || DirectoryExists;

    /// <summary>
    /// Returns <c>true</c> if a file exists at the path; otherwise, <c>false</c>.
    /// </summary>
    public bool FileExists => File.Exists(path);

    /// <summary>
    /// Returns <c>true</c> if the path exists and is a directory; otherwise, <c>false</c>.
    /// </summary>
    public bool DirectoryExists => System.IO.Directory.Exists(path);

    /// <summary>
    /// Gets the file extension of the current path, including the leading period (".") if an extension is present.
    /// Returns an empty string if the path does not contain a file extension.
    /// </summary>
    public string Extension
    {
        get
        {
            return Path.GetExtension(path);
        }
    }

    /// <summary>
    /// Gets the root directory of the current path.
    /// </summary>
    public ChainablePath Root => From(Path.GetPathRoot(path));

    /// <summary>
    /// Gets a value indicating whether the path represented by the current object points to an existing file.
    /// </summary>
    public bool IsFile => File.Exists(ToString());

    /// <summary>
    /// Gets a value indicating whether the current path represents an existing directory.
    /// </summary>
    public bool IsDirectory => System.IO.Directory.Exists(ToString());

    /// <summary>
    /// Gets a <see cref="ChainablePath"/> instance representing the current working directory of the application.
    /// </summary>
    public static ChainablePath Current => From(Environment.CurrentDirectory);

    /// <summary>
    /// Gets a <see cref="ChainablePath"/> instance representing the system's temporary directory.
    /// </summary>
    public static ChainablePath Temp => From(Path.GetTempPath());

    /// <summary>
    /// Returns a new <see cref="ChainablePath"/> instance representing the path relative to the specified base path.
    /// </summary>
    /// <param name="basePath">
    /// The base path to which the current path should be relativized. It must be an absolute path.
    /// </param>
    /// <returns>
    /// A <see cref="ChainablePath"/> instance representing the relative path from the base path to this path.
    /// </returns>
    /// <exception cref="ArgumentException">
    /// Thrown if <paramref name="basePath"/> is not absolute, or if this path is not absolute.
    /// </exception>
#if NET6_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
    public ChainablePath AsRelativeTo(ChainablePath basePath)
    {
        return Path.GetRelativePath(basePath.ToString()!, path).ToPath();
    }
#endif

    /// <summary>
    /// Returns the string representation of the current <see cref="ChainablePath"/> instance.
    /// </summary>
    public override string ToString()
    {
        return path;
    }

    /// <summary>
    /// Allows casting a <see cref="ChainablePath"/> instance to a string so it can be used anywhere where a path as string is expected.
    /// </summary>
    public static implicit operator string(ChainablePath chainablePath)
    {
        return chainablePath.ToString();
    }

    /// <summary>
    /// Allows casting a string to a <see cref="ChainablePath"/> instance.
    /// </summary>
    /// <remarks>
    /// Serves as a shortcut for <see cref="ChainablePath.From"/>.
    /// </remarks>
    public static implicit operator ChainablePath(string path)
    {
        return From(path);
    }

    /// <summary>
    /// Converts the current <see cref="ChainablePath"/> instance to a <see cref="DirectoryInfo"/> object.
    /// </summary>
    public DirectoryInfo ToDirectoryInfo()
    {
        return new DirectoryInfo(ToString());
    }

    /// <summary>
    /// Converts the current <see cref="ChainablePath"/> instance to a <see cref="FileInfo"/> object.
    /// </summary>
    public FileInfo ToFileInfo()
    {
        return new FileInfo(ToString());
    }
}

#if PATHY_PUBLIC
public static class StringExtensions
#else
internal static class StringExtensions
#endif
{
    /// <summary>
    /// Converts the specified string representation of a path to a <see cref="ChainablePath"/> instance.
    /// </summary>
    /// <param name="path">
    /// The string representation of the path to convert.
    /// </param>
    /// <returns>
    /// A <see cref="ChainablePath"/> instance representing the specified path.
    /// </returns>
    /// <exception cref="ArgumentException">
    /// Thrown if the <paramref name="path"/> is null, empty, or invalid.
    /// </exception>
    public static ChainablePath ToPath(this string path)
    {
        return ChainablePath.From(path);
    }
}
