// <autogenerated />

using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;

// ReSharper disable UseIndexFromEndExpression

#pragma warning disable

namespace Pathy
{
    /// <summary>
    /// Represents an absolute or relative path to a directory or file that simplifies operations like combining paths using
    /// the <c>/</c> operator
    /// </summary>
#if PATHY_PUBLIC
    public readonly record struct ChainablePath
#else
    [global::Microsoft.CodeAnalysis.Embedded]
    internal readonly record struct ChainablePath
#endif
    {
        private readonly string path = string.Empty;

        private ChainablePath(string path)
        {
            this.path = path;
        }

        /// <summary>
        /// Represents an empty <see cref="ChainablePath"/> instance.
        /// </summary>
        public static ChainablePath Empty { get; } = new(string.Empty);

        /// <summary>
        /// Represents a <see cref="ChainablePath"/> not pointing to any file or directory.
        /// </summary>
        /// <remarks>
        /// Implements the Null Pattern and should be used as a replacement of <see cref="Empty"/>
        /// </remarks>
        public static ChainablePath Null { get; } = new(string.Empty);

        /// <summary>
        /// Gets a default, empty <see cref="ChainablePath"/> instance.
        /// </summary>
        public static ChainablePath New => new(string.Empty);

        /// <summary>
        /// Creates a new instance of <see cref="ChainablePath"/> representing the specified path.
        /// </summary>
        /// <param name="path">
        /// The string representation of the path. This can be relative or absolute.
        /// </param>
        /// <returns>
        /// A <see cref="ChainablePath"/> object representing the normalized path.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// Thrown if the <paramref name="path"/> is null, empty, or invalid.
        /// </exception>
        public static ChainablePath From(string path)
        {
            if (path is null or { Length: 0 })
            {
                throw new ArgumentException("Path cannot be null or empty", nameof(path));
            }

            try
            {
                path = NormalizeSlashes(path);

                if (path[path.Length - 1] == Path.VolumeSeparatorChar)
                {
                    path += Path.DirectorySeparatorChar;
                }

                if (Path.IsPathRooted(path))
                {
                    return new ChainablePath(Path.GetFullPath(path));
                }

                return new ChainablePath(path);
            }
            catch (NotSupportedException)
            {
                throw new ArgumentException($"Path {path} is not valid", nameof(path));
            }
        }

        /// <summary>
        /// Creates a new instance of <see cref="ChainablePath"/> representing the first existing path from the specified list of paths.
        /// </summary>
        /// <param name="paths">
        /// An array of string representations of paths to check for existence. Paths are checked in the order provided.
        /// </param>
        /// <returns>
        /// A <see cref="ChainablePath"/> object representing the first path that exists or <see cref="Empty"/> if none exist.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the <paramref name="paths"/> array is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// Thrown if the <paramref name="paths"/> array is empty.
        /// </exception>
        public static ChainablePath FindFirst(params string[] paths)
        {
            if (paths == null)
            {
                throw new ArgumentNullException(nameof(paths));
            }

            return FindFirst(paths.Select(From).ToArray());
        }

        /// <summary>
        /// Creates a new instance of <see cref="ChainablePath"/> representing the first existing path from the specified list of paths.
        /// </summary>
        /// <param name="paths">
        /// An array of <see cref="ChainablePath"/> instances to check for existence. Paths are checked in the order provided.
        /// </param>
        /// <returns>
        /// A <see cref="ChainablePath"/> object representing the first path that exists or <see cref="Empty"/> if none exist.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the <paramref name="paths"/> array is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// Thrown if the <paramref name="paths"/> array is empty.
        /// </exception>
        public static ChainablePath FindFirst(params ChainablePath[] paths)
        {
            if (paths == null)
            {
                throw new ArgumentNullException(nameof(paths));
            }

            if (paths.Length == 0)
            {
                throw new ArgumentException("At least one path must be provided", nameof(paths));
            }

            foreach (var path in paths)
            {
                if (path.Exists)
                {
                    return path;
                }
            }

            return Empty;
        }

        private static string NormalizeSlashes(string path)
        {
            return path.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
        }

        /// <summary>
        /// Combines a <see cref="ChainablePath"/> instance with a string representing a sub-path while
        /// handling the path separators suitable for the specific operating system.
        /// </summary>
        /// <example>
        /// <code>
        /// var combinedPath = ChainablePath.From("C:/BasePath") / "SubPath" / "File.txt";
        /// </code>
        /// </example>
        /// <remarks>
        /// You don't need to add any slashes before the sub-path. The operator will handle it for you.
        /// </remarks>
        /// <param name="leftPath">
        /// The base <see cref="ChainablePath"/> to which the <paramref name="subPath"/> will be appended.
        /// </param>
        /// <param name="subPath">
        /// The string representation of the relative or additional path to combine with <paramref name="leftPath"/>.
        /// </param>
        /// <returns>
        /// A new <see cref="ChainablePath"/> instance representing the combined path.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if either <paramref name="leftPath"/> or <paramref name="subPath"/> is null.
        /// </exception>
        public static ChainablePath operator /(ChainablePath leftPath, string subPath)
        {
            return From(Path.Combine(leftPath.path, subPath));
        }

        /// <summary>
        /// Combines a <see cref="ChainablePath"/> instance with a string representing a sub-path while
        /// handling the path separators suitable for the specific operating system.
        /// </summary>
        /// <example>
        /// <code>
        /// var combinedPath = ChainablePath.From("C:/BasePath") / "SubPath" / "File.txt";
        /// </code>
        /// </example>
        /// <remarks>
        /// You don't need to add any slashes before the sub-path. The operator will handle it for you.
        /// </remarks>
        /// <param name="leftPath">
        /// The base <see cref="ChainablePath"/> to which the <paramref name="subPath"/> will be appended.
        /// </param>
        /// <param name="subPath">
        /// The string representation of the relative or additional path to combine with <paramref name="leftPath"/>.
        /// </param>
        /// <returns>
        /// A new <see cref="ChainablePath"/> instance representing the combined path.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if either <paramref name="leftPath"/> or <paramref name="subPath"/> is null.
        /// </exception>
        public static ChainablePath operator /(ChainablePath? leftPath, string subPath)
        {
            return From(Path.Combine(leftPath.GetValueOrDefault(New), subPath));
        }

#if NET6_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        /// <summary>
        /// Navigates to the parent directory of the specified <see cref="ChainablePath"/> when using the range operator <c>..</c>.
        /// </summary>
        /// <example>
        /// <code>
        /// var path = ChainablePath.Current / .. / .. / "file.txt";
        /// // Equivalent to: ChainablePath.Current.Parent.Parent / "file.txt"
        /// </code>
        /// </example>
        /// <param name="leftPath">
        /// The base <see cref="ChainablePath"/> from which to navigate to the parent.
        /// </param>
        /// <param name="range">
        /// The range operator. Only the <c>..</c> range operator (representing all elements) is supported.
        /// </param>
        /// <returns>
        /// A new <see cref="ChainablePath"/> instance representing the parent directory of <paramref name="leftPath"/>.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// Thrown if <paramref name="range"/> is not the <c>..</c> range operator.
        /// </exception>
        /// <remarks>
        /// This operator is designed to work specifically with the <c>..</c> range operator to provide
        /// a more intuitive syntax for navigating to parent directories. The <c>..</c> operator creates
        /// a <see cref="Range.All"/> range, which this method interprets as "navigate to parent".
        /// Using any other range value will throw an <see cref="ArgumentException"/>.
        /// </remarks>
        public static ChainablePath operator /(ChainablePath leftPath, Range range)
        {
            // Validate that the range is the '..' operator (which is Range.All)
            if (!Range.All.Equals(range))
            {
                throw new ArgumentException(
                    "Only the '..' range operator is supported for parent directory navigation. " +
                    "The range operator should be '..' (not a specific range like '1..3').",
                    nameof(range));
            }

            return leftPath.Parent;
        }
#endif

        /// <summary>
        /// Adds a raw string to the end of a <see cref="ChainablePath"/> instance.
        /// </summary>
        /// <param name="leftPath">
        /// The base <see cref="ChainablePath"/> object representing an initial path.
        /// </param>
        /// <param name="additionalPath">
        /// The additional string representing a relative path or file extension (with dot) to append to the <paramref name="leftPath"/>.
        /// </param>
        /// <returns>
        /// A new <see cref="ChainablePath"/> instance representing the combined path of <paramref name="leftPath"/> and <paramref name="additionalPath"/>.
        /// </returns>
        public static ChainablePath operator +(ChainablePath leftPath, string additionalPath)
        {
            return From(leftPath.ToString() + additionalPath);
        }

        /// <summary>
        /// Gets a value indicating whether the current <see cref="ChainablePath"/> instance is equal to <see cref="ChainablePath.Null"/>.
        /// </summary>
        public bool IsNull => Equals(Null);

        /// <summary>
        /// Gets the name of the file or directory represented by the current path, without the parent directory.
        /// </summary>
        public string Name => Path.GetFileName(path);

        /// <summary>
        /// If the current path represents a file, gets the directory of that file.
        /// Or, if the current path represents a directory, gets the parent directory.
        /// Returns <see cref="Empty"/> if the path represents the root of a file system.
        /// </summary>
        public ChainablePath Directory
        {
            get
            {
                string directory = DirectoryName;
                if (directory.Length > 0)
                {
                    return From(directory);
                }

                return Empty;
            }
        }

        /// <summary>
        /// If the current path represents a file, gets the directory of that file.
        /// Or, if the current path represents a directory, gets the parent directory.
        /// Returns <see cref="Empty"/> if the path represents the root of a file system.
        /// </summary>
        public ChainablePath Parent => From(DirectoryName);

        /// <summary>
        /// If the current path represents a file, gets the directory of that file.
        /// Or, if the current path represents a directory, gets the parent directory.
        /// Returns an empty string if the path represents the root of a file system.
        /// </summary>
        public string DirectoryName
        {
            get
            {
                return Path.GetDirectoryName(path.TrimEnd(Path.DirectorySeparatorChar)) ?? "";
            }
        }

        /// <summary>
        /// Indicates whether the current path is rooted, meaning it begins with a root component such as
        /// a drive letter (e.g., "C:\") or directory separator (e.g., "/").
        /// Returns <c>true</c> if the path is rooted; otherwise, <c>false</c>.
        /// </summary>
        public bool IsRooted => Path.IsPathRooted(path);

        /// <summary>
        /// Returns <c>true</c> if the path represents an existing file or directory; otherwise, returns <c>false</c>.
        /// </summary>
        public bool Exists => FileExists || DirectoryExists;

        /// <summary>
        /// Returns <c>true</c> if a file exists at the path; otherwise, <c>false</c>.
        /// </summary>
        public bool FileExists => File.Exists(path);

        /// <summary>
        /// Returns <c>true</c> if the path exists and is a directory; otherwise, <c>false</c>.
        /// </summary>
        public bool DirectoryExists => System.IO.Directory.Exists(path);

        /// <summary>
        /// Gets the file extension of the current path, including the leading period (".") if an extension is present.
        /// Returns an empty string if the path does not contain a file extension.
        /// </summary>
        public string Extension
        {
            get
            {
                return Path.GetExtension(path);
            }
        }

        /// <summary>
        /// Gets the root directory of the current path.
        /// </summary>
        public ChainablePath Root => From(Path.GetPathRoot(path));

        /// <summary>
        /// Gets a value indicating whether the path represented by the current object points to an existing file.
        /// </summary>
        public bool IsFile => File.Exists(ToString());

        /// <summary>
        /// Gets a value indicating whether the current path represents an existing directory.
        /// </summary>
        public bool IsDirectory => System.IO.Directory.Exists(ToString());

        /// <summary>
        /// Gets a <see cref="ChainablePath"/> instance representing the current working directory of the application.
        /// </summary>
        public static ChainablePath Current => From(Environment.CurrentDirectory);

        /// <summary>
        /// Gets a <see cref="ChainablePath"/> instance representing the system's temporary directory.
        /// </summary>
        public static ChainablePath Temp => From(Path.GetTempPath());

        /// <summary>
        /// Gets the last write time of the file or directory in Coordinated Universal Time (UTC).
        /// </summary>
        /// <remarks>
        /// For files, returns the result of <see cref="File.GetLastWriteTimeUtc"/>.
        /// For directories, returns the result of <see cref="Directory.GetLastWriteTimeUtc"/>.
        /// If the path does not exist, returns <see cref="DateTime.MinValue"/>.
        /// </remarks>
        public DateTime LastWriteTimeUtc
        {
            get
            {
                if (FileExists)
                {
                    return File.GetLastWriteTimeUtc(path);
                }
                else if (DirectoryExists)
                {
                    return System.IO.Directory.GetLastWriteTimeUtc(path);
                }
                
                return DateTime.MinValue;
            }
        }

        /// <summary>
        /// Returns a new <see cref="ChainablePath"/> instance representing the path relative to the specified base path.
        /// </summary>
        /// <param name="basePath">
        /// The base path to which the current path should be relativized. It must be an absolute path.
        /// </param>
        /// <returns>
        /// A <see cref="ChainablePath"/> instance representing the relative path from the base path to this path.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// Thrown if <paramref name="basePath"/> is not absolute, or if this path is not absolute.
        /// </exception>
#if NET6_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
    public ChainablePath AsRelativeTo(ChainablePath basePath)
    {
        return Path.GetRelativePath(basePath.ToString()!, path).ToPath();
    }
#endif

        /// <summary>
        /// Returns the string representation of the current <see cref="ChainablePath"/> instance.
        /// </summary>
        public override string ToString()
        {
            return path;
        }

        /// <summary>
        /// Allows casting a <see cref="ChainablePath"/> instance to a string so it can be used anywhere where a path as string is expected.
        /// </summary>
        public static implicit operator string(ChainablePath chainablePath)
        {
            return chainablePath.ToString();
        }

        /// <summary>
        /// Allows casting a string to a <see cref="ChainablePath"/> instance.
        /// </summary>
        /// <remarks>
        /// Serves as a shortcut for <see cref="ChainablePath.From"/>.
        /// </remarks>
        public static implicit operator ChainablePath(string path)
        {
            return From(path);
        }

        /// <summary>
        /// Converts the current <see cref="ChainablePath"/> instance to a <see cref="DirectoryInfo"/> object.
        /// </summary>
        public DirectoryInfo ToDirectoryInfo()
        {
            return new DirectoryInfo(ToString());
        }

        /// <summary>
        /// Converts the current <see cref="ChainablePath"/> instance to a <see cref="FileInfo"/> object.
        /// </summary>
        public FileInfo ToFileInfo()
        {
            return new FileInfo(ToString());
        }

        /// <summary>
        /// Determines if the current path has the specified file extension.
        /// </summary>
        /// <param name="extension">
        /// The file extension to check for, with or without the leading period (e.g., ".txt").
        /// </param>
        public bool HasExtension(string extension)
        {
            if (string.IsNullOrEmpty(extension))
            {
                throw new ArgumentException("Extension cannot be null or empty", nameof(extension));
            }

            // Ensure the extension starts with a dot
            if (!extension.StartsWith(".", StringComparison.InvariantCulture))
            {
                extension = '.' + extension;
            }

            return string.Equals(Extension, extension, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Determines if the current path has the specified file or directory name (case-insensitive).
        /// </summary>
        /// <param name="name">
        /// The name to check for (e.g., "MyFile.txt").
        /// </param>
        public bool HasName(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("Name cannot be null or empty", nameof(name));
            }

            return string.Equals(Name, name, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Converts the current <see cref="ChainablePath"/> to an absolute path using the current working directory.
        /// </summary>
        public ChainablePath ToAbsolute()
        {
            return Path.GetFullPath(this);
        }

        /// <summary>
        /// Converts the current <see cref="ChainablePath"/> instance to an absolute path, using the specified parent
        /// path as the base.
        /// </summary>
        public object ToAbsolute(ChainablePath parentPath)
        {
            if (!parentPath.IsRooted)
            {
                throw new ArgumentException("Parent path must be an absolute path", nameof(parentPath));
            }

            return From(Path.Combine(parentPath.ToString(), ToString()));
        }

        /// <summary>
        /// Finds the first parent directory in the hierarchy that contains a file matching any of the provided wildcard patterns.
        /// </summary>
        /// <param name="wildcards">One or more wildcard patterns to match against files in parent directories (e.g., "*.sln", "*.slnx").</param>
        /// <returns>
        /// A <see cref="ChainablePath"/> representing the first parent directory that contains a matching file,
        /// or <see cref="Empty"/> if no parent directory contains a matching file.
        /// </returns>
        /// <exception cref="ArgumentException">Thrown if no wildcards are provided or if any wildcard is null or empty.</exception>
        public ChainablePath FindParentWithFileMatching(params string[] wildcards)
        {
            if (wildcards == null || wildcards.Length == 0)
            {
                throw new ArgumentException("At least one wildcard pattern must be provided", nameof(wildcards));
            }

            foreach (string wildcard in wildcards)
            {
                if (string.IsNullOrWhiteSpace(wildcard))
                {
                    throw new ArgumentException("Wildcard patterns cannot be null or empty", nameof(wildcards));
                }
            }

            // Start from the directory containing this path, or the path itself if it's already a directory
            ChainablePath currentDirectory = IsFile ? Directory : this;

            while (currentDirectory != Root && currentDirectory != Empty && currentDirectory.DirectoryExists)
            {
                foreach (string wildcard in wildcards)
                {
                    // Check if any files in the current directory match the wildcards
                    if (System.IO.Directory.GetFiles(currentDirectory, wildcard).Any())
                    {
                        return currentDirectory;
                    }
                }

                // Move to the parent directory
                currentDirectory = currentDirectory.Parent;
            }

            return Empty;
        }
    }

#if PATHY_PUBLIC
    public static class StringExtensions
#else
    [global::Microsoft.CodeAnalysis.Embedded]
    internal static class StringExtensions
#endif
    {
        /// <summary>
        /// Converts the specified string representation of a path to a <see cref="ChainablePath"/> instance.
        /// </summary>
        /// <param name="path">
        /// The string representation of the path to convert.
        /// </param>
        /// <returns>
        /// A <see cref="ChainablePath"/> instance representing the specified path.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// Thrown if the <paramref name="path"/> is null, empty, or invalid.
        /// </exception>
        public static ChainablePath ToPath(this string path)
        {
            return ChainablePath.From(path);
        }
    }
}

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
namespace Microsoft.CodeAnalysis
{
    /// <summary>
    /// A special attribute recognized by Roslyn, that marks a type as "embedded", meaning it won't ever be visible from other assemblies.
    /// </summary>
    [AttributeUsage(AttributeTargets.All)]
    [ExcludeFromCodeCoverage]
    internal sealed class EmbeddedAttribute : Attribute
    {
    }
}
