// <autogenerated />

using System;
using System.IO;
using System.Linq;

// ReSharper disable UseIndexFromEndExpression

#pragma warning disable

namespace Pathy;

/// <summary>
/// Represents an absolute or relative path to a directory or file that simplifies operations like combining paths using
/// the <c>/</c> operator
/// </summary>
#if PATHY_PUBLIC
public readonly record struct ChainablePath
#else
internal readonly record struct ChainablePath
#endif
{
    private readonly string path = string.Empty;

    private ChainablePath(string path)
    {
        this.path = path;
    }

    /// <summary>
    /// Represents an empty <see cref="ChainablePath"/> instance.
    /// </summary>
    public static ChainablePath Empty { get; } = new(string.Empty);

    /// <summary>
    /// Gets a default, empty <see cref="ChainablePath"/> instance.
    /// </summary>
    public static ChainablePath New => new(string.Empty);

    /// <summary>
    /// Creates a new instance of <see cref="ChainablePath"/> representing the specified path.
    /// </summary>
    /// <param name="path">
    /// The string representation of the path. This can be relative or absolute.
    /// </param>
    /// <returns>
    /// A <see cref="ChainablePath"/> object representing the normalized path.
    /// </returns>
    /// <exception cref="ArgumentException">
    /// Thrown if the <paramref name="path"/> is null, empty, or invalid.
    /// </exception>
    public static ChainablePath From(string path)
    {
        if (path is null or { Length: 0 })
        {
            throw new ArgumentException("Path cannot be null or empty", nameof(path));
        }

        try
        {
            path = NormalizeSlashes(path);

            if (path[path.Length - 1] == Path.VolumeSeparatorChar)
            {
                path += Path.DirectorySeparatorChar;
            }

            if (Path.IsPathRooted(path))
            {
                return new ChainablePath(Path.GetFullPath(path));
            }

            return new ChainablePath(path);
        }
        catch (NotSupportedException)
        {
            throw new ArgumentException($"Path {path} is not valid", nameof(path));
        }
    }

    /// <summary>
    /// Creates a new instance of <see cref="ChainablePath"/> representing the first existing path from the specified list of paths.
    /// </summary>
    /// <param name="paths">
    /// An array of string representations of paths to check for existence. Paths are checked in the order provided.
    /// </param>
    /// <returns>
    /// A <see cref="ChainablePath"/> object representing the first path that exists or <see cref="Empty"/> if none exist.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown if the <paramref name="paths"/> array is null.
    /// </exception>
    /// <exception cref="ArgumentException">
    /// Thrown if the <paramref name="paths"/> array is empty.
    /// </exception>
    public static ChainablePath FindFirst(params string[] paths)
    {
        if (paths == null)
        {
            throw new ArgumentNullException(nameof(paths));
        }

        return FindFirst(paths.Select(From).ToArray());
    }

    /// <summary>
    /// Creates a new instance of <see cref="ChainablePath"/> representing the first existing path from the specified list of paths.
    /// </summary>
    /// <param name="paths">
    /// An array of <see cref="ChainablePath"/> instances to check for existence. Paths are checked in the order provided.
    /// </param>
    /// <returns>
    /// A <see cref="ChainablePath"/> object representing the first path that exists or <see cref="Empty"/> if none exist.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown if the <paramref name="paths"/> array is null.
    /// </exception>
    /// <exception cref="ArgumentException">
    /// Thrown if the <paramref name="paths"/> array is empty.
    /// </exception>
    public static ChainablePath FindFirst(params ChainablePath[] paths)
    {
        if (paths == null)
        {
            throw new ArgumentNullException(nameof(paths));
        }

        if (paths.Length == 0)
        {
            throw new ArgumentException("At least one path must be provided", nameof(paths));
        }

        foreach (var path in paths)
        {
            if (path.Exists)
            {
                return path;
            }
        }

        return Empty;
    }

    private static string NormalizeSlashes(string path)
    {
        return path.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
    }

    /// <summary>
    /// Combines a <see cref="ChainablePath"/> instance with a string representing a sub-path while
    /// handling the path separators suitable for the specific operating system.
    /// </summary>
    /// <example>
    /// <code>
    /// var combinedPath = ChainablePath.From("C:/BasePath") / "SubPath" / "File.txt";
    /// </code>
    /// </example>
    /// <remarks>
    /// You don't need to add any slashes before the sub-path. The operator will handle it for you.
    /// </remarks>
    /// <param name="leftPath">
    /// The base <see cref="ChainablePath"/> to which the <paramref name="subPath"/> will be appended.
    /// </param>
    /// <param name="subPath">
    /// The string representation of the relative or additional path to combine with <paramref name="leftPath"/>.
    /// </param>
    /// <returns>
    /// A new <see cref="ChainablePath"/> instance representing the combined path.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown if either <paramref name="leftPath"/> or <paramref name="subPath"/> is null.
    /// </exception>
    public static ChainablePath operator /(ChainablePath leftPath, string subPath)
    {
        return From(Path.Combine(leftPath.path, subPath));
    }

    /// <summary>
    /// Combines a <see cref="ChainablePath"/> instance with a string representing a sub-path while
    /// handling the path separators suitable for the specific operating system.
    /// </summary>
    /// <example>
    /// <code>
    /// var combinedPath = ChainablePath.From("C:/BasePath") / "SubPath" / "File.txt";
    /// </code>
    /// </example>
    /// <remarks>
    /// You don't need to add any slashes before the sub-path. The operator will handle it for you.
    /// </remarks>
    /// <param name="leftPath">
    /// The base <see cref="ChainablePath"/> to which the <paramref name="subPath"/> will be appended.
    /// </param>
    /// <param name="subPath">
    /// The string representation of the relative or additional path to combine with <paramref name="leftPath"/>.
    /// </param>
    /// <returns>
    /// A new <see cref="ChainablePath"/> instance representing the combined path.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown if either <paramref name="leftPath"/> or <paramref name="subPath"/> is null.
    /// </exception>
    public static ChainablePath operator /(ChainablePath? leftPath, string subPath)
    {
        return From(Path.Combine(leftPath.GetValueOrDefault(New), subPath));
    }

    /// <summary>
    /// Adds a raw string to the end of a <see cref="ChainablePath"/> instance.
    /// </summary>
    /// <param name="leftPath">
    /// The base <see cref="ChainablePath"/> object representing an initial path.
    /// </param>
    /// <param name="additionalPath">
    /// The additional string representing a relative path or file extension (with dot) to append to the <paramref name="leftPath"/>.
    /// </param>
    /// <returns>
    /// A new <see cref="ChainablePath"/> instance representing the combined path of <paramref name="leftPath"/> and <paramref name="additionalPath"/>.
    /// </returns>
    public static ChainablePath operator +(ChainablePath leftPath, string additionalPath)
    {
        return From(leftPath.ToString() + additionalPath);
    }

    /// <summary>
    /// Gets the name of the file or directory represented by the current path, without the parent directory.
    /// </summary>
    public string Name => Path.GetFileName(path);

    /// <summary>
    /// If the current path represents a file, gets the directory of that file.
    /// Or, if the current path represents a directory, gets the parent directory.
    /// Returns <see cref="Empty"/> if the path represents the root of a file system.
    /// </summary>
    public ChainablePath Directory
    {
        get
        {
            string directory = DirectoryName;
            if (directory.Length > 0)
            {
                return From(directory);
            }

            return Empty;
        }
    }

    /// <summary>
    /// If the current path represents a file, gets the directory of that file.
    /// Or, if the current path represents a directory, gets the parent directory.
    /// Returns <see cref="Empty"/> if the path represents the root of a file system.
    /// </summary>
    public ChainablePath Parent => From(DirectoryName);

    /// <summary>
    /// If the current path represents a file, gets the directory of that file.
    /// Or, if the current path represents a directory, gets the parent directory.
    /// Returns an empty string if the path represents the root of a file system.
    /// </summary>
    public string DirectoryName
    {
        get
        {
            return Path.GetDirectoryName(path.TrimEnd(Path.DirectorySeparatorChar)) ?? "";
        }
    }

    /// <summary>
    /// Indicates whether the current path is rooted, meaning it begins with a root component such as
    /// a drive letter (e.g., "C:\") or directory separator (e.g., "/").
    /// Returns <c>true</c> if the path is rooted; otherwise, <c>false</c>.
    /// </summary>
    public bool IsRooted => Path.IsPathRooted(path);

    /// <summary>
    /// Returns <c>true</c> if the path represents an existing file or directory; otherwise, returns <c>false</c>.
    /// </summary>
    public bool Exists => FileExists || DirectoryExists;

    /// <summary>
    /// Returns <c>true</c> if a file exists at the path; otherwise, <c>false</c>.
    /// </summary>
    public bool FileExists => File.Exists(path);

    /// <summary>
    /// Returns <c>true</c> if the path exists and is a directory; otherwise, <c>false</c>.
    /// </summary>
    public bool DirectoryExists => System.IO.Directory.Exists(path);

    /// <summary>
    /// Gets the file extension of the current path, including the leading period (".") if an extension is present.
    /// Returns an empty string if the path does not contain a file extension.
    /// </summary>
    public string Extension
    {
        get
        {
            return Path.GetExtension(path);
        }
    }

    /// <summary>
    /// Gets the root directory of the current path.
    /// </summary>
    public ChainablePath Root => From(Path.GetPathRoot(path));

    /// <summary>
    /// Gets a value indicating whether the path represented by the current object points to an existing file.
    /// </summary>
    public bool IsFile => File.Exists(ToString());

    /// <summary>
    /// Gets a value indicating whether the current path represents an existing directory.
    /// </summary>
    public bool IsDirectory => System.IO.Directory.Exists(ToString());

    /// <summary>
    /// Gets a <see cref="ChainablePath"/> instance representing the current working directory of the application.
    /// </summary>
    public static ChainablePath Current => From(Environment.CurrentDirectory);

    /// <summary>
    /// Gets a <see cref="ChainablePath"/> instance representing the system's temporary directory.
    /// </summary>
    public static ChainablePath Temp => From(Path.GetTempPath());

    /// <summary>
    /// Returns a new <see cref="ChainablePath"/> instance representing the path relative to the specified base path.
    /// </summary>
    /// <param name="basePath">
    /// The base path to which the current path should be relativized. It must be an absolute path.
    /// </param>
    /// <returns>
    /// A <see cref="ChainablePath"/> instance representing the relative path from the base path to this path.
    /// </returns>
    /// <exception cref="ArgumentException">
    /// Thrown if <paramref name="basePath"/> is not absolute, or if this path is not absolute.
    /// </exception>
#if NET6_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
    public ChainablePath AsRelativeTo(ChainablePath basePath)
    {
        return Path.GetRelativePath(basePath.ToString()!, path).ToPath();
    }
#endif

    /// <summary>
    /// Returns the string representation of the current <see cref="ChainablePath"/> instance.
    /// </summary>
    public override string ToString()
    {
        return path;
    }

    /// <summary>
    /// Allows casting a <see cref="ChainablePath"/> instance to a string so it can be used anywhere where a path as string is expected.
    /// </summary>
    public static implicit operator string(ChainablePath chainablePath)
    {
        return chainablePath.ToString();
    }

    /// <summary>
    /// Allows casting a string to a <see cref="ChainablePath"/> instance.
    /// </summary>
    /// <remarks>
    /// Serves as a shortcut for <see cref="ChainablePath.From"/>.
    /// </remarks>
    public static implicit operator ChainablePath(string path)
    {
        return From(path);
    }

    /// <summary>
    /// Converts the current <see cref="ChainablePath"/> instance to a <see cref="DirectoryInfo"/> object.
    /// </summary>
    public DirectoryInfo ToDirectoryInfo()
    {
        return new DirectoryInfo(ToString());
    }

    /// <summary>
    /// Converts the current <see cref="ChainablePath"/> instance to a <see cref="FileInfo"/> object.
    /// </summary>
    public FileInfo ToFileInfo()
    {
        return new FileInfo(ToString());
    }

    /// <summary>
    /// Determines if the current path has the specified file extension.
    /// </summary>
    /// <param name="extension">
    /// The file extension to check for, with or without the leading period (e.g., ".txt").
    /// </param>
    public bool HasExtension(string extension)
    {
        if (string.IsNullOrEmpty(extension))
        {
            throw new ArgumentException("Extension cannot be null or empty", nameof(extension));
        }

        // Ensure the extension starts with a dot
        if (!extension.StartsWith(".", StringComparison.InvariantCulture))
        {
            extension = '.' + extension;
        }

        return string.Equals(Extension, extension, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Converts the current <see cref="ChainablePath"/> to an absolute path using the current working directory.
    /// </summary>
    public ChainablePath ToAbsolute()
    {
        return Path.GetFullPath(this);
    }

    /// <summary>
    /// Converts the current <see cref="ChainablePath"/> instance to an absolute path, using the specified parent
    /// path as the base.
    /// </summary>
    public object ToAbsolute(ChainablePath parentPath)
    {
        if (!parentPath.IsRooted)
        {
            throw new ArgumentException("Parent path must be an absolute path", nameof(parentPath));
        }

        return From(Path.Combine(parentPath.ToString(), this.ToString()));
    }

    /// <summary>
    /// Finds the first parent directory in the hierarchy that contains a file matching any of the provided wildcard patterns.
    /// </summary>
    /// <param name="wildcards">One or more wildcard patterns to match against files in parent directories (e.g., "*.sln", "*.slnx").</param>
    /// <returns>
    /// A <see cref="ChainablePath"/> representing the first parent directory that contains a matching file,
    /// or <see cref="Empty"/> if no parent directory contains a matching file.
    /// </returns>
    /// <exception cref="ArgumentException">Thrown if no wildcards are provided or if any wildcard is null or empty.</exception>
    public ChainablePath FindParentWithFileMatching(params string[] wildcards)
    {
        if (wildcards == null || wildcards.Length == 0)
        {
            throw new ArgumentException("At least one wildcard pattern must be provided", nameof(wildcards));
        }

        foreach (string wildcard in wildcards)
        {
            if (string.IsNullOrWhiteSpace(wildcard))
            {
                throw new ArgumentException("Wildcard patterns cannot be null or empty", nameof(wildcards));
            }
        }

        // Start from the directory containing this path, or the path itself if it's already a directory
        ChainablePath currentDirectory = IsFile ? Directory : this;

        while (currentDirectory != Root && currentDirectory != Empty && currentDirectory.DirectoryExists)
        {
            foreach (string wildcard in wildcards)
            {
                // Check if any files in the current directory match the wildcards
                if (System.IO.Directory.GetFiles(currentDirectory, wildcard).Any())
                {
                    return currentDirectory;
                }
            }

            // Move to the parent directory
            currentDirectory = currentDirectory.Parent;
        }

        return Empty;
    }
}

#if PATHY_PUBLIC
public static class StringExtensions
#else
internal static class StringExtensions
#endif
{
    /// <summary>
    /// Converts the specified string representation of a path to a <see cref="ChainablePath"/> instance.
    /// </summary>
    /// <param name="path">
    /// The string representation of the path to convert.
    /// </param>
    /// <returns>
    /// A <see cref="ChainablePath"/> instance representing the specified path.
    /// </returns>
    /// <exception cref="ArgumentException">
    /// Thrown if the <paramref name="path"/> is null, empty, or invalid.
    /// </exception>
    public static ChainablePath ToPath(this string path)
    {
        return ChainablePath.From(path);
    }
}
